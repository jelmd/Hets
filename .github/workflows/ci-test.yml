# Build hets and run related tests for CI
name: CI-Test

env:
  SKIP_STACK: 0
  SKIP_BUILD: 0
  SKIP_TEST: 0
  SKIP_HADDOCK: 0
  #PKG_CACHE: /var/tmp/pkgs
  SMART_CACHE: 1
  NO_DOCS: 1
  #MKDBG: 1
  # Dir cannot be directly in /tmp or /var/tmp because Microsoft does not
  # understand dir mode 01777 and errors out with dumb messages. /dev/shm/
  # does not work for stack - not enough space. /tmp as well as /var/tmp are on
  # /dev/sd*.
  STACK_ROOT: /var/tmp/hets/stack
  GAH: utils/gha-helper.sh
  MISSING_PKGS: 'libpango1.0-dev libgtk2.0-dev'
  # GHA var settings totally sucks: impossible to use already defined vars =8-(
  #HETS_BASEDIR: /var/tmp/hets
  #HETS_BUILD_DIR: ${HETS_BASEDIR}/build
  #PREFIX: /tmp/hets-install
  #PATH: ${PREFIX}/bin:${STACK_ROOT}/bin:${PATH}
  #HETS_LIB: /var/tmp/Hets-lib
  #HETS_MAGIC: ${TRAVIS_BUILD_DIR}/magic/hets.magic

# Controls when the workflow will run
on:
  # Triggers the workflow on push or pull request cwfor the given branches
  push:
    branches:
      - gha
  pull_request:
    branches:
      - gha

# A workflow run is made up of one or more jobs that can run seq. or in parallel
# but always in a separate, fresh container. So each job needs to fetch the work
# from previous jobs and checkout the repo again, if needed.
#
# Re-usable workflows? Forget this non-sense. Write a script and put it in there
# than you have re-usable stuff which can be run on any step, several times ...
jobs:
  job_1:
    name: Stack
    runs-on: ubuntu-18.04
    # If the job takes longer than 30 min, something is going wrong. E.g. stack
    # sometimes goes in an endless loop. We prefer to kill instead of wasting
    # valueable credits (2000 min/month). 
    timeout-minutes: 30
    steps:
      # Info about the running environment makes troubleshooting easier. < 1s
      - name: Dump GitHub context
        env:
          GITHUB_CONTEXT: ${{ toJSON(github) }}
        run: |
          mkdir -p ${{ env.STACK_ROOT }}
          printf "$GITHUB_CONTEXT\n"
          df -h
          mount

      # Actually we only need stack.yml to calculate the hash. But the checkout
      # takes ~ 5s, only => not worth to optimize/add complexity.
      - name: Checkout
        uses: actions/checkout@v2

      # If stack.yaml has not been changed, we can try to use a cached copy,
      # which saves ~15..20 min. On hit takes ~ 25s
      - name: Fetch stack cache
        id: stack_cache
        uses: actions/cache@v2
        with:
          path: ${{ env.STACK_ROOT }}
          key: stack-${{ runner.os }}-${{ hashFiles('stack.yaml') }}

      # Add missing packages. Since it is not a minimal server image, almost
      # everything is already installed. But this makes update time longer: 30s
      - name: Update packages
        if: steps.stack_cache.outputs.cache-hit != 'true'
        run: |
          echo 'man-db man-db/auto-update boolean false' | sudo debconf-set-selections
          sudo apt-get install ksh93 || sudo apt-get install ksh
          sudo apt-get install ${{ env.MISSING_PKGS }}
          ${{ env.GAH }} -c showEnv
          cp -L `which ksh93` ${{ env.STACK_ROOT }}/

      - name: Build stack
        if: steps.stack_cache.outputs.cache-hit != 'true'
        run: |
          make stack && rm -rf ${{ env.STACK_ROOT }}/programs/x86_64-linux/*/share/doc || mv ${{ env.STACK_ROOT }} ${{ env.STACK_ROOT }}.fail
          ls -al ${{ env.STACK_ROOT }}/programs/x86_64-linux/*/share/
          ls -al ${{ env.STACK_ROOT }} && du -sh ${{ env.STACK_ROOT }}
          ls -al ${{ github.workspace }}
